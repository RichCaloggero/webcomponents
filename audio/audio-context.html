<link rel="import" href="/bower_components/polymer/polymer-element.html">


<dom-module id="audio-context">
<template>
<style>
:host {
display: block;
}
</style>

<div class="audio-context">
<h1>{{name}}</h1>
<slot></slot>
</div>
</template>

<script>
"use strict";

window._AudioContext_ = class _AudioContext_ extends Polymer.Element {
static get is() { return "audio-context"; }

static get properties() {
return {
_debug: {
type: Boolean,
value: false,
//observer: "_debugChanged"
}, // _debug

_debugConnection: {
type: Boolean,
value: true
}, // _debugConnection
name: {
type: String,
value: "",
//observer: "nameChanged"
} // name
}; // return
} // get properties

constructor () {
super ();

if (! window.AudioContext) {
alert ("webaudio not available");
return;
} // if

if (window.audio) {
//alert ("only one audio context per document");
} else {
window.audio = new AudioContext();
} // if

this.audio = window.audio;
} // constructor

connectedCallback () {
super.connectedCallback ();
if (this._debug) alert (`debugging enabled in ${this.audioNode} context ${this.name}`);
} // connectedCallback

_bypass (value) {
if (this._in && this._out  && this.audioNode) {
//alert (`bypass ${value} on ${this.audioNode}, ${this._in}, ${this._out}`);
if (value) {
this.disconnect ();
 this._in.connect (this._out);
} else {
this.disconnect ();
this.connect ();
} // if
} // if
} // _bypass

connect () {
//alert (`running internal connect on ${this.audioNode}`);
this._in.connect (this.audioNode)
.connect (this._out);
} // connect

disconnect () {
//alert (`running internal disconnect on ${this.audioNode}`);
this._in.disconnect();
this.audioNode.disconnect();
} // disconnect


contextCheck (name) {
var parentName = this.parentNode.localName;
//alert ("parentName: " + parentName);
if (parentName !== "audio-series" && parentName !== "audio-parallel") {
alert (`${name} : element must be child of audio-parallel or audio-series to participate in audio graph`);
//throw new Error ("audio graph error");
return false;
} // if

return true;
} // contextCheck

whenAllChildrenLoaded (loadedCallback) {
var children = Array.from(this.childNodes).filter ((node) => node.nodeType === 1);
var loaded = children.map ((element) => {
//alert ("element: " + element);
return customElements.whenDefined (element.localName);
});

Promise.all (loaded).then (() => {
//alert (`all ${loaded.length} elements loaded`);
loadedCallback.call (this, children);
}).catch (function (error) {
alert (error);
throw error;
});
} // whenAllChildrenLoaded

addFieldLabels () {
Array.from(this.shadowRoot.querySelectorAll (".field"))
.forEach ((field) => {
var name, control, label, id;
name = field.getAttribute("data-name");
label = field.querySelector("label");
control = field.querySelector("input, select, textarea");
id = this._id + "-" + name;
//alert (`field: ${name} ${field} ${control} ${label}`);
control.setAttribute("id", id);
control.setAttribute ("role", "application");
label.setAttribute ("for", id);
});
} // addFieldLabels

/*_debugChanged (value) {
this._debug = value;
} // _debugChanged
*/

/*nameChanged (value) {
this.name = value;
} // nameChanged
*/

} // class _AudioContext_

window.customElements.define(_AudioContext_.is, _AudioContext_);
</script>
</dom-module>
