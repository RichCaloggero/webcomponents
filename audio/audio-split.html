<!--<link rel="import" href="../polymer/lib/elements/dom-if.html">-->
<!--<link rel="import" href="../polymer/lib/elements/dom-repeat.html">-->

<dom-module id="audio-split">
<template>
<style>
:host {
display: block;
}
</style>

<div class="audio-split">
</div>

</template>

<script>
"use strict";

class AudioSplit extends _AudioContext_ {
static get is() { return "audio-split"; }

constructor () {
super ();
this._in = audio.createChannelSplitter (2);
this._out = audio.createChannelMerger (2);
if (this._debug) alert (`created ${this._in}`);
} // constructor

connectedCallback () {
this.whenAllChildrenLoaded (this.connectAll);
} // connectedCallback

connectAll (nodes) {
var channels = [this.firstElementChild, this.lastElementChild];

if (this._debug) alert (`split: connecting all ${nodes.length} nodes`);
if (nodes.length !== 2) {
alert (`split: needs exactly 2 children, one for each channel; ${nodes.length} children found`);
return;
} // if

for (var i in channels) {
let channel = channels[i];

if (typeof AudioSeries !== "undefined") {
if (channel instanceof AudioSeries) {
let _first = channel.firstElementChild.audioNode || channel.firstElementChild._in;
let _last = channel.lastElementChild.audioNode || channel.lastElementChild._out;
if (this._debug) alert (`split (channel ${Number(i)+1}): connecting ${this._in} to ${_first} and ${_last} to ${this._out}`);
this._in.connect (_first, 0);
_last.connect (this._out, 0, i);
} // if
} // if series
} // for
/*// hack -- need to have in and out on series and parallel nodes
alert (`split: connecting ${this.merge} to ${this.nextElementSibling.audioNode}`);
this.merge.connect (this.nextElementSibling.audioNode);
this.audioNode.disconnect (this.nextElementSibling.audioNode);
*/

} // connectAll

} // class AudioSplit

window.customElements.define(AudioSplit.is, AudioSplit);
</script>
</dom-module>
